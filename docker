#!/bin/bash

set -euo pipefail

if [[ "${DOND_SHIM_DEBUG:-false}" == true ]]; then
  set -x
fi

function get_container_id() {
  local cpuset_output
  cpuset_output=$(head -1 /proc/self/cpuset)
  basename "${cpuset_output}"
}

function get_container_root_dir() {
  local container_id="${1}"

  docker.orig inspect --format '{{.GraphDriver.Data.MergedDir}}' "${container_id}"
}

function set_container_volumes() {
  local container_id="${1}"

  local docker_output
  docker_output=$(
    docker.orig inspect \
      --format '{{range .Mounts}}{{printf "%s:%s\n" .Source .Destination}}{{end}}' \
      "${container_id}"
  )

  readarray -t container_volumes <<<"${docker_output}"
}

function fix_volume_arg() {
  local source="${volume_arg%%":"*}"
  local destination="${volume_arg#*":"}"

  # Fix relative paths as docker needs absolute paths
  # if [[ "${source}" == "./"* ]]; then
  #   source="${PWD}/${source#"./"}"
  # fi

  if [[ "${source}" == "/"* ]]; then
    if [[ "${container_data_fetched}" == false ]]; then
      container_id="$(get_container_id)"
      container_root_dir="$(get_container_root_dir "${container_id}")"
      set_container_volumes "${container_id}"
      readonly container_id container_root_dir container_volumes
      container_data_fetched=true
    fi

    for container_volume in "${container_volumes[@]}"; do
      local container_volume_source="${container_volume%%":"*}"
      local container_volume_destination="${container_volume#*":"}"

      if [[ "${source}" == "${container_volume_destination}" ]]; then
        volume_arg="${container_volume_source}:${destination}"
        return
      fi

      if [[ "${source}" == "${container_volume_destination}/"* ]]; then
        volume_arg="${container_volume_source}${source#"${container_volume_destination}"}:${destination}"
        return
      fi

      # Check if there is some container_volume mounted within the source
      # Example:
      # First container mounts --volume "${PWD}/testfile:/home/rootless/testfile"
      # Second container mounts --volume /home/rootless:/wd
      # Then the second container should also mount --volume "${PWD}/testfile:/wd/testfile" (extra_arg)
      if [[ "${container_volume_destination}" == "${source}/"* ]]; then
        # Convert /home/rootless/testfile (container_volume_destination) to /wd/testfile (destination path)
        extra_args+=(--volume "${container_volume_source}:${destination}/${container_volume_destination#"${source}/"}")
      fi
    done

    volume_arg="${container_root_dir}${source}:${destination}"
    return
  fi

  volume_arg="${source}:${destination}"
}

function get_docker_options_with_value() {
  local -n target_array="${1}"
  shift 1
  local command=("${@}")

  local help_output
  help_output="$(docker.orig "${command[@]}" --help)"

  readarray -t help_lines <<<"${help_output}"
  target_array=()
  for line in "${help_lines[@]}"; do
    # second group is the short option (optional)
    # third group is the long option
    if [[ "${line}" =~ ^[[:space:]]+((-[a-zA-Z]),[[:space:]])?(--[a-z0-9-]+)[[:space:]][a-z]+[[:space:]]+.*$ ]]; then
      if [[ -n "${BASH_REMATCH[2]}" ]]; then
        target_array+=("${BASH_REMATCH[2]}")
      fi
      target_array+=("${BASH_REMATCH[3]}")
    fi
  done
}

original_args=("$@")

skip_next=false
parsing="global"
global_args=()
docker_global_options_fetched=false
found_first_global_positional=false
command_args=()
image_args=()
for i in "${!original_args[@]}"; do
  arg="${original_args[${i}]}"

  if [[ "${parsing}" == "global" ]]; then
    global_args+=("${arg}")

    if [[ "${skip_next}" == true ]]; then
      skip_next=false
      continue
    fi

    if [[ "${arg}" == "-"* ]]; then
      if [[ "${found_first_global_positional}" == false ]]; then
        if [[ "${docker_global_options_fetched}" == false ]]; then
          options_with_value=()
          get_docker_options_with_value options_with_value
          docker_global_options_fetched=true
        fi

        for option_with_value in "${options_with_value[@]}"; do
          if [[ "${arg}" == "${option_with_value}" ]]; then
            skip_next=true
            continue
          fi
        done
      fi
      continue
    fi

    if [[ "${arg}" == "run" || "${arg}" == "create" ]]; then
      options_with_value=()
      get_docker_options_with_value options_with_value "${arg}"
      parsing="command"
    elif [[ "${arg}" == "container" ]]; then
      found_first_global_positional=true
      true
    else
      # Skip if command is not run, create, container run, or container create
      if [[ "${DOND_SHIM_PRINT_COMMAND:-false}" == true ]]; then
        echo docker.orig "${original_args[@]}"
        exit 0
      else
        exec docker.orig "${original_args[@]}"
      fi
    fi
  elif [[ "${parsing}" == "command" ]]; then
    command_args+=("${arg}")

    if [[ "${skip_next}" == true ]]; then
      skip_next=false
      continue
    fi

    if [[ "${arg}" == "-"* ]]; then
      for option_with_value in "${options_with_value[@]}"; do
        if [[ "${arg}" == "${option_with_value}" ]]; then
          skip_next=true
          continue
        fi
      done
      continue
    fi

    # If this is reached, then the first positional argument has been found
    parsing="image"
  elif [[ "${parsing}" == "image" ]]; then
    image_args+=("${arg}")
  fi
done

container_data_fetched=false
fixed_args=()
extra_args=()
fix_next_arg=false
for arg in "${command_args[@]}"; do
  if [[ "${fix_next_arg}" == true ]]; then
    fix_next_arg=false
    volume_arg="${arg}"
    fix_volume_arg
    arg="${volume_arg}"
  elif [[ "${arg}" == "-v" || "${arg}" == "--volume" ]]; then
    fix_next_arg=true
  elif [[ "${arg}" == "-v="* || "${arg}" == "--volume="* ]]; then
    dot_dot_volume="${arg%%"="*}"
    volume_arg="${arg#*"="}"
    fix_volume_arg
    arg="${dot_dot_volume}=${volume_arg}"
  fi

  fixed_args+=("${arg}" "${extra_args[@]}")
  extra_args=()
done

final_command=(docker.orig "${global_args[@]}" "${fixed_args[@]}" "${image_args[@]}")

if [[ "${DOND_SHIM_PRINT_COMMAND:-false}" == true ]]; then
  echo "${final_command[@]}"
else
  exec "${final_command[@]}"
fi
